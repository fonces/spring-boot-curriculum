# Step 7: Spring Data JPAでCRUDの基本

## 🎯 このステップの目標

- `@Entity`アノテーションでエンティティクラスを作成する
- `JpaRepository`インターフェースを理解する
- データベースにデータを保存（Create）する
- データベースからデータを取得（Read）する
- 実際に動作するユーザー登録・一覧取得APIを実装する

**所要時間**: 約1時間

---

## 📋 事前準備

- Step 6で構築したMySQLデータベース環境
- `spring-boot-starter-data-jpa`と`mysql-connector-j`の依存関係が追加済み

**Step 6をまだ完了していない場合**: [Step 6: MySQL環境構築](STEP_6.md)を先に進めてください。

---

## 💡 JPAとは？

### JPA (Java Persistence API)

**JPA** = Javaでデータベース操作を行うための標準仕様

**特徴**:
- ✅ SQLを書かなくてもデータベース操作ができる
- ✅ オブジェクト指向でデータを扱える（ORM）
- ✅ データベースの種類を問わない（MySQL、PostgreSQL等）

### ORM (Object-Relational Mapping)

**Javaのクラス（オブジェクト）** と **データベースのテーブル（リレーショナル）** を対応付ける技術

```
Javaクラス          ←→    データベーステーブル
-----------              -------------------
User.java                users テーブル
├── id                   ├── id (BIGINT)
├── name                 ├── name (VARCHAR)
└── email                └── email (VARCHAR)
```

### Spring Data JPA

JPAをさらに使いやすくしたSpringのライブラリ

**便利な機能**:
- リポジトリインターフェースを作るだけでCRUD操作が使える
- メソッド名から自動的にクエリを生成
- ページネーション、ソート機能が簡単

---

## 🚀 ステップ1: エンティティクラスの作成

### 1-1. Userエンティティの作成

新しいパッケージ`entity`を作成し、`User`クラスを作成します。

**ファイルパス**: `src/main/java/com/example/hellospringboot/entity/User.java`

```java
package com.example.hellospringboot.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "users")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(nullable = false, unique = true, length = 100)
    private String email;

    @Column
    private Integer age;
}
```

### 1-2. アノテーションの解説

#### `@Entity`
```java
@Entity
```
- このクラスがJPAのエンティティであることを示す
- データベースのテーブルに対応するクラス

#### `@Table`
```java
@Table(name = "users")
```
- テーブル名を指定（省略時はクラス名が使われる）
- `User` → `user`テーブルになるが、明示的に`users`と指定

#### `@Id`
```java
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;
```
- `@Id`: 主キーであることを示す
- `@GeneratedValue`: 値の自動生成
- `GenerationType.IDENTITY`: データベースの自動採番機能を使用

#### `@Column`
```java
@Column(nullable = false, length = 100)
private String name;

@Column(nullable = false, unique = true, length = 100)
private String email;
```
- `nullable = false`: NOT NULL制約
- `unique = true`: ユニーク制約（重複不可）
- `length = 100`: VARCHAR(100)

### 1-3. アプリケーション起動とテーブル確認

アプリケーションを起動します。

コンソールに以下のようなSQLが表示されます：

```sql
Hibernate: 
    create table users (
       id bigint generated by default as identity,
        age integer,
        email varchar(100) not null,
        name varchar(100) not null,
        primary key (id)
    )
Hibernate: 
    alter table if exists users 
       add constraint UK_6dotkott2kjsp8vw4d0m25fb7 unique (email)
```

**これで自動的にテーブルが作成されました！**

**データベースの確認方法：**

**DBeaver（プロフェッショナルなDBビューアー）**
- 無料で多機能なデータベース管理ツール
- [https://dbeaver.io/](https://dbeaver.io/)
- MySQL、PostgreSQLなど多数のデータベースに対応
- 接続情報: Host `localhost`, Port `3306`, Database `hellospringboot`, User `dbuser`, Password `dbpassword`

**MySQL CLI**
```bash
docker exec -it spring-boot-mysql mysql -udbuser -pdbpassword hellospringboot
```

> **💡 ヒント**: 実務ではDBeaverなどの専用ツールを使うことが多いです

---

## 🚀 ステップ2: リポジトリの作成

### 2-1. UserRepositoryインターフェースの作成

新しいパッケージ`repository`を作成し、`UserRepository`インターフェースを作成します。

**ファイルパス**: `src/main/java/com/example/hellospringboot/repository/UserRepository.java`

```java
package com.example.hellospringboot.repository;

import com.example.hellospringboot.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    // メソッドは自動的に提供される（まだ何も書かない）
}
```

### 2-2. コードの解説

#### `JpaRepository<User, Long>`
```java
public interface UserRepository extends JpaRepository<User, Long>
```
- `User`: エンティティの型
- `Long`: 主キー（ID）の型

#### 自動的に提供されるメソッド

`JpaRepository`を継承するだけで、以下のメソッドが使えます：

| メソッド | 機能 |
|---------|------|
| `save(entity)` | 保存（Insert/Update） |
| `findById(id)` | IDで検索 |
| `findAll()` | 全件取得 |
| `deleteById(id)` | IDで削除 |
| `count()` | 件数カウント |
| `existsById(id)` | 存在チェック |

**メソッドを実装する必要はありません！**

---

## 🚀 ステップ3: サービス層の作成

### 3-1. UserServiceの作成

新しいパッケージ`service`を作成し、`UserService`クラスを作成します。

**ファイルパス**: `src/main/java/com/example/hellospringboot/service/UserService.java`

```java
package com.example.hellospringboot.service;

import com.example.hellospringboot.entity.User;
import com.example.hellospringboot.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@RequiredArgsConstructor
public class UserService {

    private final UserRepository userRepository;

    /**
     * ユーザーを作成
     */
    public User createUser(User user) {
        return userRepository.save(user);
    }

    /**
     * 全ユーザーを取得
     */
    public List<User> getAllUsers() {
        return userRepository.findAll();
    }
}
```

### 3-2. コードの解説

#### `@Service`
```java
@Service
```
- このクラスがサービス層であることを示す
- Spring Bootが自動的にBeanとして登録

#### `@RequiredArgsConstructor` (Lombok)
```java
@RequiredArgsConstructor
public class UserService {
    private final UserRepository userRepository;
```
- `final`フィールドを引数に持つコンストラクタを自動生成
- 依存性注入（DI）に使用

**Lombokなしで書くと**:
```java
public class UserService {
    private final UserRepository userRepository;
    
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}
```

---

## 🚀 ステップ4: コントローラーの作成

### 4-1. Phase 1のDTOを削除（オプション）

Phase 1で作成した`UserRequest`と`UserResponse`はエンティティと構造が異なるため、
今回は直接エンティティを使用します（後のステップでDTOを再導入します）。

### 4-2. UserControllerの作成（新規）

Phase 1の`UserController`を以下のように**書き換え**ます。

**ファイルパス**: `src/main/java/com/example/hellospringboot/controller/UserController.java`

```java
package com.example.hellospringboot.controller;

import com.example.hellospringboot.entity.User;
import com.example.hellospringboot.service.UserService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/users")
@RequiredArgsConstructor
public class UserController {

    private final UserService userService;

    /**
     * ユーザー作成
     * POST /api/users
     */
    @PostMapping
    public ResponseEntity<User> createUser(@RequestBody User user) {
        User createdUser = userService.createUser(user);
        return ResponseEntity.status(HttpStatus.CREATED).body(createdUser);
    }

    /**
     * 全ユーザー取得
     * GET /api/users
     */
    @GetMapping
    public ResponseEntity<List<User>> getAllUsers() {
        List<User> users = userService.getAllUsers();
        return ResponseEntity.ok(users);
    }
}
```

### 4-3. コードの解説

#### `@RequestMapping("/api/users")`
```java
@RequestMapping("/api/users")
```
- このコントローラーの全エンドポイントは`/api/users`で始まる
- RESTful APIの慣習に従う

#### `ResponseEntity<T>`
```java
public ResponseEntity<User> createUser(@RequestBody User user) {
    User createdUser = userService.createUser(user);
    return ResponseEntity.status(HttpStatus.CREATED).body(createdUser);
}
```
- HTTPステータスコードとボディを明示的に返せる
- `HttpStatus.CREATED` → 201 Created
- `ResponseEntity.ok()` → 200 OK

---

## ✅ ステップ5: 動作確認

### 5-1. アプリケーション起動

アプリケーションを起動します。

### 5-2. ユーザー作成（POST）

```bash
curl -X POST http://localhost:8080/api/users \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Taro Yamada",
    "email": "taro@example.com",
    "age": 30
  }'
```

**期待される結果**:
```json
{
  "id": 1,
  "name": "Taro Yamada",
  "email": "taro@example.com",
  "age": 30
}
```

コンソールには実行されたSQLが表示されます：

```sql
Hibernate: 
    insert 
    into
        users
        (age, email, name) 
    values
        (?, ?, ?)
```

### 5-3. さらにユーザーを追加

```bash
curl -X POST http://localhost:8080/api/users \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Hanako Tanaka",
    "email": "hanako@example.com",
    "age": 25
  }'

curl -X POST http://localhost:8080/api/users \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Jiro Suzuki",
    "email": "jiro@example.com",
    "age": 28
  }'
```

### 5-4. 全ユーザー取得（GET）

```bash
curl http://localhost:8080/api/users
```

**期待される結果**:
```json
[
  {
    "id": 1,
    "name": "Taro Yamada",
    "email": "taro@example.com",
    "age": 30
  },
  {
    "id": 2,
    "name": "Hanako Tanaka",
    "email": "hanako@example.com",
    "age": 25
  },
  {
    "id": 3,
    "name": "Jiro Suzuki",
    "email": "jiro@example.com",
    "age": 28
  }
]
```

コンソールのSQL：

```sql
Hibernate: 
    select
        u1_0.id,
        u1_0.age,
        u1_0.email,
        u1_0.name 
    from
        users u1_0
```

### 5-5. データベースで確認

**DBeaverまたはMySQL CLIで確認:**

1. ツールにアクセス/接続
2. 以下のSQLを実行：

```sql
SELECT * FROM users;
```

**結果**: 作成したユーザーが表示されます。

---

## 🎨 データの永続性を確認

### 実験: データの永続化確認

1. アプリケーションを**停止**
2. 再度**起動**
3. `curl http://localhost:8080/api/users`を実行

**結果**: データが残っています！

**理由**: MySQLはディスクにデータを保存するため、再起動してもデータが永続化されます。


---

## 🎨 チャレンジ課題

### チャレンジ 1: 重複メール登録の動作確認

同じメールアドレスで2回ユーザーを作成してみてください。

```bash
curl -X POST http://localhost:8080/api/users \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Test User",
    "email": "test@example.com",
    "age": 20
  }'

# もう一度同じメールで登録
curl -X POST http://localhost:8080/api/users \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Another User",
    "email": "test@example.com",
    "age": 25
  }'
```

**期待される挙動**: エラーが発生（`unique constraint`違反）

**次のステップで適切なエラーハンドリングを学びます。**

### チャレンジ 2: Productエンティティの作成

商品を管理する`Product`エンティティを作成してください。

**要件**:
- テーブル名: `products`
- フィールド:
  - `id` (Long, 主キー, 自動生成)
  - `name` (String, NOT NULL, 最大100文字)
  - `price` (Integer, NOT NULL)
  - `category` (String, 最大50文字)

**ヒント**:
1. `Product.java`エンティティを作成
2. `ProductRepository.java`を作成
3. `ProductService.java`を作成
4. `ProductController.java`を作成

### チャレンジ 3: ユーザー数を返すAPI

登録されているユーザーの総数を返すエンドポイントを追加してください。

**エンドポイント**: `GET /api/users/count`

**ヒント**:
```java
// UserService
public long countUsers() {
    return userRepository.count();
}

// UserController
@GetMapping("/count")
public ResponseEntity<Long> countUsers() {
    long count = userService.countUsers();
    return ResponseEntity.ok(count);
}
```

---

## 🐛 トラブルシューティング

### "Table 'users' not found"

**原因**: テーブルが作成されていない

**解決策**:
1. `User`クラスに`@Entity`アノテーションがあるか確認
2. `application.yml`で`ddl-auto: update`になっているか確認
3. アプリケーションを再起動

### "No property 'xxx' found for type 'User'"

**原因**: エンティティクラスにフィールドやGetterがない

**解決策**:
- Lombokの`@Data`または`@Getter`が付いているか確認
- フィールド名のスペルミスがないか確認

### "Could not write JSON: Infinite recursion"

**原因**: 循環参照（次のステップで扱うリレーションシップで発生しやすい）

**解決策**: 今のステップでは発生しませんが、注意が必要です。

### POSTで"Unsupported Media Type"

**原因**: `Content-Type: application/json`ヘッダーがない

**解決策**:
```bash
curl -X POST http://localhost:8080/api/users \
  -H "Content-Type: application/json" \  # これを忘れずに
  -d '{"name":"Test","email":"test@example.com","age":20}'
```

### IDが自動生成されない

**症状**: IDが常にnullまたは0

**原因**: `@GeneratedValue`がない

**解決策**:
```java
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)  // これを追加
private Long id;
```

---

## 📚 このステップで学んだこと

- ✅ `@Entity`でエンティティクラスを定義
- ✅ `@Table`, `@Id`, `@GeneratedValue`, `@Column`の使い方
- ✅ `JpaRepository`を継承してリポジトリを作成
- ✅ `save()`でデータ保存、`findAll()`で全件取得
- ✅ サービス層でビジネスロジックを分離
- ✅ コントローラーでRESTful APIを実装
- ✅ `ResponseEntity`でHTTPステータスコードを制御
- ✅ Hibernateが自動的にテーブルを作成する仕組み

---

## 💡 補足: JPAのライフサイクル

### エンティティの状態

JPAのエンティティには状態があります：

```
新規作成 → 永続化 → 分離 → 削除
(New)    (Managed) (Detached) (Removed)
```

#### New（新規）
```java
User user = new User();
user.setName("Taro");
// まだデータベースに保存されていない
```

#### Managed（永続化）
```java
User savedUser = userRepository.save(user);
// データベースに保存され、JPAが管理している
```

#### Detached（分離）
```java
// トランザクション終了後、エンティティは分離状態
// データベースとの同期が切れる
```

#### Removed（削除）
```java
userRepository.delete(user);
// データベースから削除される
```

**Step 9で詳しく学びます。**

---

## 💡 補足: なぜRepositoryとServiceを分けるのか？

### アーキテクチャの分離

```
Controller層（UserController）
    ↓ APIリクエストを受け取る
Service層（UserService）
    ↓ ビジネスロジックを実行
Repository層（UserRepository）
    ↓ データベースアクセス
Database（MySQL）
```

### メリット

1. **責務の分離**
   - Controller: HTTPリクエスト/レスポンス処理
   - Service: ビジネスロジック
   - Repository: データアクセス

2. **テストしやすい**
   - Serviceだけをテスト可能
   - Repositoryをモックに置き換えられる

3. **再利用性**
   - 同じServiceを複数のControllerから使用可能

**Step 13でレイヤー化アーキテクチャを深く学びます。**

---

## 🔄 Gitへのコミットとレビュー依頼

進捗を記録してレビューを受けましょう：

```bash
git add .
git commit -m "Step 7: Spring Data JPAでCRUD基本実装完了"
git push origin main
```

コミット後、**Slackでレビュー依頼**を出してフィードバックをもらいましょう！

---

## ➡️ 次のステップ

レビューが完了したら、[Step 8: CRUD操作の完成](STEP_8.md)へ進みましょう！

次のステップでは、Update（更新）とDelete（削除）機能を追加して、
完全なCRUD操作を実装します。また、IDで特定のユーザーを取得する機能も追加します！

---

お疲れさまでした！ 🎉

SQLを書かずに、Javaのコードだけでデータベース操作ができました！
これがJPAの強力な機能です。次のステップでCRUDを完成させましょう！
